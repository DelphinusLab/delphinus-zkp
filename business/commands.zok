from "./markle-tree" import getAccountIndex, getAssetIndex, getValueDefault, LeafInfo, getRootHashAfterUpdate, getValueBySelector, getRootHashAfterUpdateBySelector, checkLeafInfo
from "./sign.zok" import checkSign
import "./sha256" as sha256
import "utils/pack/u32/pack128" as pack128

struct Command {
    field op
    field[7] args
}

const bool[2] axSelector = [false, false]
const bool[2] aySelector = [false, true]
const bool[2] nonceSelector = [true, false]
const field metaAsset = 0

def setAmountBySelector(field root, LeafInfo leafInfo, field v, bool[2] selector) -> field:
    return getRootHashAfterUpdateBySelector(leafInfo, v, selector)

def addAmount(field root, LeafInfo leafInfo, field amount) -> field:
    field valueIn = getValueDefault(leafInfo)
    field valueOut = valueIn + amount
    assert(valueIn < valueOut)
    return getRootHashAfterUpdate(leafInfo, valueOut)

def subAmount(field root, LeafInfo leafInfo, field amount) -> field:
    field valueIn = getValueDefault(leafInfo)
    field valueOut = valueIn - amount
    assert(valueOut < valueIn)
    return getRootHashAfterUpdate(leafInfo, valueOut)

def checkAccount(LeafInfo leafInfo, field account) -> bool:
    return getAccountIndex(leafInfo) == account

def checkAsset(LeafInfo leafInfo, field asset) -> bool:
    return getAssetIndex(leafInfo) == asset

def checkToken(field token) -> bool:
    return token >= 4 && token < 1024

def handleDeposit(Command command, field root, LeafInfo leafInfo) -> field:
    field account = command.args[0]
    field token = command.args[1]
    field amount = command.args[2]
    for u32 i in 3..7 do
        assert(command.args[i] == 0)
    endfor

    assert(checkLeafInfo(root, leafInfo))
    assert(checkToken(token))
    assert(checkAsset(leafInfo, token))
    assert(checkAccount(leafInfo, account))
    return addAmount(root, leafInfo, amount)

def handleWithdraw(Command command, field root, LeafInfo[2] leafInfos) -> field:
    field account = command.args[0]
    field token = command.args[1]
    field amount = command.args[2]
    field nonce = command.args[3]
    field[2] r = command.args[4..6]
    field s = command.args[6]

    LeafInfo leafInfo = leafInfos[0]

    // check sign
    field[2] a = [
        getValueBySelector(leafInfo, axSelector),
        getValueBySelector(leafInfo, aySelector)
    ]
    assert(checkLeafInfo(root, leafInfo))
    assert(checkAccount(leafInfo, account))
    assert(checkAsset(leafInfo, metaAsset))
    assert(checkSign([[account, token], [amount, nonce]], r, s, a))

    // check and update nonce
    field old_nonce = getValueBySelector(leafInfo, nonceSelector)
    assert(old_nonce + 1 == nonce)
    root = setAmountBySelector(root, leafInfo, nonce, nonceSelector)

    // sub amount
    leafInfo = leafInfos[1]
    assert(checkAccount(leafInfo, account))
    assert(checkToken(token))
    assert(checkAsset(leafInfo, token))
    return subAmount(root, leafInfo, amount)

def shaCommands<N>(Command[N] commands) -> field[2]:
    field[N * 4][2] data = [[0; 2]; N * 4]
    for u32 i in 0..N do
        Command command = commands[i]
        data[i * 4] = [command.op, command.args[0]]
        data[i * 4 + 1] = [command.args[1], command.args[2]]
        data[i * 4 + 2] = [command.args[3], command.args[4]]
        data[i * 4 + 3] = [command.args[5], command.args[6]]
    endfor
    u32[8] hash = sha256(data)
    return [
        pack128(hash[0..4]),
        pack128(hash[4..8])
    ]

def main(private Command command, field root, private LeafInfo[2] leafInfos, field[2] hash) -> field:
    //return handleDeposit(command, root, leafInfo)
    assert(hash == shaCommands([command]))
    return handleWithdraw(command, root, leafInfos)