import "utils/pack/u32/pack128" as pack128
import "./withdraw" as withdraw
import "./swap" as swap
import "./supply" as supply
import "./retrieve" as retrieve
import "./deposit" as deposit
import "./addpool" as addpool
import "./setkey" as setkey
import "../utils/sha256" as sha256
from "./command" import Command
from "../utils/markle-tree" import LeafInfo

def shaCommands<N>(Command[N] commands) -> field[2]:
    field[N * 4][2] data = [[0; 2]; N * 4]
    for u32 i in 0..N do
        Command command = commands[i]
        data[i * 4] = [command.op, command.args[0]]
        data[i * 4 + 1] = [command.args[1], command.args[2]]
        data[i * 4 + 2] = [command.args[3], command.args[4]]
        data[i * 4 + 3] = [command.args[5], command.args[6]]
    endfor
    u32[8] hash = sha256(data)
    return [
        pack128(hash[0..4]),
        pack128(hash[4..8])
    ]

const field OP_DEPOSIT = 0
const field OP_WITHDRAW = 1
const field OP_SWAP = 2
const field OP_SUPPLY = 3
const field OP_RETRIEVE = 4
const field OP_ADDPOOL = 5
const field OP_SETKEY = 6

def op6(Command command, field root, private LeafInfo[5] leafInfos) -> field:
    return setkey(command, root, leafInfos)

def op5(Command command, field root, private LeafInfo[5] leafInfos) -> field:
    return if command.op == OP_ADDPOOL then addpool(command, root, leafInfos) else op6(command, root, leafInfos) fi

def op4(Command command, field root, private LeafInfo[5] leafInfos) -> field:
    return if command.op == OP_RETRIEVE then retrieve(command, root, leafInfos) else op5(command, root, leafInfos) fi

def op3(Command command, field root, private LeafInfo[5] leafInfos) -> field:
    return if command.op == OP_SUPPLY then supply(command, root, leafInfos) else op4(command, root, leafInfos) fi

def op2(Command command, field root, private LeafInfo[5] leafInfos) -> field:
    return if command.op == OP_SWAP then swap(command, root, leafInfos) else op3(command, root, leafInfos) fi

def op1(Command command, field root, private LeafInfo[5] leafInfos) -> field:
    return if command.op == OP_WITHDRAW then withdraw(command, root, leafInfos) else op2(command, root, leafInfos) fi

def op0(Command command, field root, private LeafInfo[5] leafInfos) -> field:
    return if command.op == OP_DEPOSIT then deposit(command, root, leafInfos) else op1(command, root, leafInfos) fi

def main(private Command command, field root, private LeafInfo[5] leafInfos, field[2] hash, field root_new):
    assert(hash == shaCommands([command]))
    root = op0(command, root, leafInfos)
    assert(root_new == root)
    return