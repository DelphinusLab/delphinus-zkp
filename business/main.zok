import "utils/pack/u32/pack128" as pack128
import "../utils/sha256" as sha256
from "./command" import Command, CommandResult
from "../utils/markle-tree" import LeafInfo, checkLeafInfo, getRootHash

import "./addpool" as addpool
import "./deposit" as deposit
import "./withdraw" as withdraw
import "./swap" as swap

/*
import "./supply" as supply
import "./retrieve" as retrieve
import "./setkey" as setkey
*/

def shaCommands<N>(Command[N] commands) -> field[2]:
    field[N * 5][2] data = [[0; 2]; N * 5]
    for u32 i in 0..N do
        Command command = commands[i]
        data[i * 4] = [command.op, command.args[0]]
        data[i * 4 + 1] = [command.args[1], command.args[2]]
        data[i * 4 + 2] = [command.args[3], command.args[4]]
        data[i * 4 + 3] = [command.args[5], command.args[6]]
        data[i * 4 + 4] = [command.args[7], 0]
    endfor
    u32[8] hash = sha256(data)
    return [
        pack128(hash[0..4]),
        pack128(hash[4..8])
    ]

const field OP_DEPOSIT = 0
const field OP_WITHDRAW = 1
const field OP_SWAP = 2
const field OP_SUPPLY = 3
const field OP_RETRIEVE = 4
const field OP_ADDPOOL = 5
const field OP_SETKEY = 6
/*
def op6(Command command, field root, private LeafInfo[5] leafInfos) -> field:
    return setkey(command, root, leafInfos)

def op5(Command command, field root, private LeafInfo[5] leafInfos) -> field:
    return if command.op == OP_ADDPOOL then addpool(command, root, leafInfos) else op6(command, root, leafInfos) fi

def op4(Command command, field root, private LeafInfo[5] leafInfos) -> field:
    return if command.op == OP_RETRIEVE then retrieve(command, root, leafInfos) else op5(command, root, leafInfos) fi

def op3(Command command, field root, private LeafInfo[5] leafInfos) -> field:
    return if command.op == OP_SUPPLY then supply(command, root, leafInfos) else op4(command, root, leafInfos) fi
    */

def op2(Command command, private LeafInfo[5] leafInfos) -> CommandResult:
    return if command.op == OP_SWAP then swap(command, leafInfos) else addpool(command, leafInfos) fi

def op1(Command command, private LeafInfo[5] leafInfos) -> CommandResult:
    return if command.op == OP_WITHDRAW then withdraw(command, leafInfos) else op2(command, leafInfos) fi

def op0(Command command, private LeafInfo[5] leafInfos) -> CommandResult:
    return if command.op == OP_DEPOSIT then deposit(command, leafInfos) else op1(command, leafInfos) fi

def main(field[2] hash, private Command command, private LeafInfo[5] leafInfos, field finalRoot):
    assert(hash == shaCommands([command]))

    for u32 i in 0..5 do
        assert(checkLeafInfo(leafInfos[i]))
    endfor

    field[5] nextRoot = [finalRoot; 5]
    for u32 i in 0..4 do
        nextRoot[i] = leafInfos[i + 1].root
    endfor

    CommandResult cres = op0(command, leafInfos)

    assert(cres.succeed)
    for u32 i in 0..5 do
        assert(getRootHash(cres.leafInfos[i]) == nextRoot[i])
    endfor

    return
